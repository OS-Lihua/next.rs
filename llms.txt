# next.rs

> The AI-native Rust web framework. Designed for LLM code generation. Zero macros. Pure method chaining.

## Core Concept

next.rs is the first web framework designed for AI to write code in.
Pure Rust function calls with method chaining — the pattern LLMs generate most reliably.
Fine-grained reactivity (signals, not virtual DOM). File-system routing. SSR + WASM hydration.

## AI Integration

- `llms.txt` — This file. Read it to generate correct next.rs code.
- `next check --json` — Structured diagnostics with fix suggestions. AI agents can parse and self-correct.
- `next context` — Generates `.next-context.json` describing project routes and components.
- `next create --template blog` — Pre-built templates: `default`, `blog`, `dashboard`.

## Quick Start

```bash
next create my-app
cd my-app
next dev
```

`next create` generates a fully working SSR + WASM hydration project:
- SSR renders HTML on the server, browser loads WASM and hydrates automatically
- Interactive components (signals, events) work in the browser without configuration
- The generated counter button proves hydration is working on first run

## Element API

All HTML elements are functions returning `Element`. Chain methods to build UI:

```rust
use react_rs_elements::html::*;
use react_rs_elements::node::IntoNode;

// Layout: div, span, p, main_el, section, article, aside, header, footer, nav
// Text: h1, h2, h3, h4, h5, h6, strong, em, code, pre
// Form: form, input, textarea, button, label, select, option
// List: ul, ol, li
// Table: table, thead, tbody, tr, th, td
// Media: img, video, audio
// Other: a, br, hr, html, head, title, body, meta, link, script, style
```

## Element Methods

```rust
// Attributes
.class("flex items-center")    .id("my-id")
.style("color: red")           .attr("data-x", "value")
.href("/about")                .src("/image.png")
.alt("description")            .type_("text")
.name("field")                 .value("initial")
.placeholder("Enter...")       .disabled(true)

// Content
.text("Static text")           .child(other_element)
.children([elem1, elem2])

// Events
.on_click(|e| { /* click */ })
.on_input(|e| { let val = e.value(); })
.on_submit(|e| { e.prevent_default(); })
.on_change(|e| { /* change */ })

// Reactive
.text_reactive(signal.map(|n| format!("Count: {}", n)))
.class_reactive(signal.map(|a| if *a { "active" } else { "" }.to_string()))
.value_reactive(signal.map(|s| s.clone()))
.bind_value(read_signal, write_signal)
.show_when(bool_signal)
.show_when_else(bool_signal, fallback_element)
```

## Reactivity (Signals)

```rust
use react_rs_core::{create_signal, create_effect, create_memo, create_scope, dispose_scope, on_cleanup};
use react_rs_elements::SignalExt;

let (count, set_count) = create_signal(0);
count.get();                    // read
set_count.set(5);               // replace
set_count.update(|n| *n += 1); // mutate

create_effect(move || { println!("{}", count.get()); });

let doubled = create_memo(move || count.get() * 2);
let text = count.map(|n| format!("Count: {}", n));

// Scope-based disposal (prevents memory leaks)
let scope = create_scope();
create_effect(move || { /* tracked effect */ });
dispose_scope(scope); // cleans up all effects in scope

// Cleanup callbacks
create_effect(move || {
    on_cleanup(|| { /* runs before re-run or on dispose */ });
});
```

## Keyed Lists

```rust
use react_rs_elements::node::each_keyed;

let (items, set_items) = create_signal(vec![("a", "Alice"), ("b", "Bob")]);
each_keyed(items, |(id, _)| id.to_string(), |(_, name), _i| {
    li().text(*name).into_node()
})
```

## Context API

```rust
use react_rs_core::{provide_context, use_context};
provide_context("theme", "dark".to_string());
let theme: Option<String> = use_context("theme");
```

## Resource (Async Data)

```rust
use react_rs_core::{create_resource, ResourceState};
let resource = create_resource::<Vec<String>>();
resource.set_ready(vec!["item".into()]);
match resource.read() {
    ResourceState::Loading => { /* spinner */ },
    ResourceState::Ready(data) => { /* show data */ },
    ResourceState::Error(e) => { /* show error */ },
}
```

## File Conventions

```
src/app/
├── layout.rs       # pub fn layout(children: Node) -> impl IntoNode
├── page.rs         # pub fn page() -> impl IntoNode
├── about/
│   └── page.rs     # /about
├── blog/
│   ├── layout.rs   # nested layout for /blog/*
│   ├── page.rs     # /blog
│   └── [slug]/
│       └── page.rs # /blog/:slug (dynamic)
└── api/
    └── users/
        └── route.rs # API route /api/users
```

## Pattern: Page Component

```rust
use react_rs_elements::html::*;
use react_rs_elements::node::IntoNode;

pub fn page() -> impl IntoNode {
    div()
        .class("container mx-auto p-4")
        .child(h1().class("text-2xl font-bold").text("My Page"))
        .child(p().text("Content here"))
}
```

## Pattern: Interactive Component

SSR + hydration works automatically. Write signals and events — they render as static HTML on the server and become interactive in the browser via WASM hydration.

```rust
use react_rs_core::create_signal;
use react_rs_elements::html::*;
use react_rs_elements::node::IntoNode;
use react_rs_elements::SignalExt;

pub fn counter() -> impl IntoNode {
    let (count, set_count) = create_signal(0);
    div()
        .child(h1().text_reactive(count.map(|n| format!("Count: {}", n))))
        .child(
            button()
                .class("px-4 py-2 bg-blue-500 text-white rounded")
                .text("Increment")
                .on_click(move |_| { set_count.update(|n| *n += 1); })
        )
}
```

## Pattern: Layout

```rust
use react_rs_elements::html::*;
use react_rs_elements::node::{IntoNode, Node};

pub fn layout(children: Node) -> impl IntoNode {
    div()
        .class("min-h-screen")
        .child(header().child(nav().child(a().href("/").text("Home"))))
        .child(main_el().class("p-4").child(children))
        .child(footer().text("© 2025"))
}
```

## Pattern: Form

```rust
use react_rs_core::create_signal;
use react_rs_elements::html::*;
use react_rs_elements::node::IntoNode;

pub fn contact_form() -> impl IntoNode {
    let (name, set_name) = create_signal(String::new());
    form()
        .on_submit(move |e| {
            e.prevent_default();
            let value = name.get();
        })
        .child(input().type_("text").placeholder("Name").bind_value(name, set_name))
        .child(button().type_("submit").text("Send"))
}
```

## Anti-patterns

- DO NOT use macros (view!, rsx!, html!) — use method chaining
- DO NOT use virtual DOM — signals handle reactivity
- DO NOT use `unsafe`
- Use `main_el()` not `main()` for <main> element (conflicts with Rust's main fn)

## CLI

```bash
next create <name>                    # Create new project (default template)
next create <name> --template blog    # Create with blog template
next create <name> --template dashboard  # Create with dashboard template
next dev                              # Dev server with auto browser refresh
next build                            # Production build (server + WASM)
next start                            # Production server
next add page /path                   # Scaffold page
next add page /path --interactive     # Scaffold page with signal pattern
next add layout /path                 # Scaffold layout
next add component name               # Scaffold component
next add component name --interactive # Component with signal pattern
next check --json                     # Structured diagnostics for AI agents
next context                          # Generate .next-context.json
```
